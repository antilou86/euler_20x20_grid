# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# What is the value of the first triangle number to have over five hundred divisors?
import math
limit = 500

def recursive_divisors(n, start=2):
    if n == 1: #if n=1 it can only have 1
        return 1

    #from wherever we currently are to the sqrt, check each natural number
    for i in range(start, int(math.sqrt(n))):
        if n % i == 0 : #if divisible, reduce as much as possible.
            print(f"divisor = {n}")
            count=1
            while n%i==0: #as long as we can keep reducing, do so.
                n/= i
                count+= 1
                print(f"count = {count}")
            #once totally reduced
            return recursive_divisors(n, i+1)*count
    return 2

def divisors(tri_num):
    #check for num of divisors
    #only for checks first half of the divisors because of the law of balanced factors
    divisors = 0
    for i in range(1, int(math.sqrt(tri_num))+1):
        if (tri_num % i)==0:
            divisors +=2
        if i*i==tri_num: #if it is a perfect square, subtract 1 to avoid adding an extra
            divisors -=1
        print(f"trinum- {tri_num}, {i}, {divisors}")
    print(f"{divisors} divisors")
    return divisors

def triangle_number_divisors(num):
#generate triangle numbers formulaically rather than iteratively.
    for n in range(1, 1000000):
        print(f"{n}")
        #test each number until we find one with the number of factors
        #n and n+1 are coprimes. because of this we can eliminate roughly half of the computations
        #so:
        if n%2==0: #if even
            #factors equal the result of -> (n/2) * (n+1)
            cnt=divisors(n/2)*divisors(n+1)
            #cnt=recursive_divisors(n/2)*recursive_divisors(n+1)
        else: #it's odd -> formula for co-prime of corresponding even n
            #opposite formula -> n * ((n+1)/2)
            cnt=divisors(n)*divisors((n+1)/2)
            #cnt=recursive_divisors(n)*recursive_divisors((n+1)/2)
        #the first one that has 500 divisors will need to be returned
        if cnt >= num:
            #formula for finding nth triangle number Tn = (n*(n+1))/2
            return (n*(n+1))/2

print(triangle_number_divisors(500))

